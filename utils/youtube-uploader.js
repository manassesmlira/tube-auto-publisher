const { google } = require('googleapis');
const fs = require('fs');
const path = require('path');
require('dotenv').config();

// Configurar autentica√ß√£o Google
const oauth2Client = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET,
    'http://localhost:3333/oauth/callback'
);

oauth2Client.setCredentials({
    refresh_token: process.env.GOOGLE_REFRESH_TOKEN
});

const youtube = google.youtube({ version: 'v3', auth: oauth2Client });

/**
 * Mapeia categoria do Notion para ID do YouTube
 * @param {string} category - Categoria do Notion
 * @returns {string} - ID da categoria YouTube
 */
function getCategoryId(category) {
    const categoryMap = {
        'Education': '27',
        'Entertainment': '24',
        'Music': '10',
        'Gaming': '20',
        'Sports': '17',
        'Science & Technology': '28',
        'News & Politics': '25',
        'Howto & Style': '26',
        'People & Blogs': '22',
        'Comedy': '34',
        'Film & Animation': '1',
        'Autos & Vehicles': '2'
    };
    
    return categoryMap[category] || '27'; // Default: Education
}

/**
 * Formata status de privacidade
 * @param {string} privacy - Status do Notion
 * @returns {string} - Status YouTube v√°lido
 */
function formatPrivacyStatus(privacy) {
    const privacyMap = {
        'Public': 'public',
        'Unlisted': 'unlisted',
        'Private': 'private'
    };
    
    const formatted = privacyMap[privacy] || 'public';
    console.log(`üîí Privacidade: ${privacy} ‚Üí ${formatted}`);
    return formatted;
}

/**
 * Processa e formata tags
 * @param {string} tagsString - String de tags separadas por v√≠rgula
 * @returns {Array} - Array de tags v√°lidas
 */
function processTags(tagsString) {
    if (!tagsString) return [];
    
    const tags = tagsString
        .split(',')
        .map(tag => tag.trim())
        .filter(tag => tag.length > 0 && tag.length <= 500) // Limite do YouTube
        .slice(0, 500); // M√°ximo 500 tags
    
    console.log(`üè∑Ô∏è Tags processadas: ${tags.length} tag(s)`);
    console.log(`   ${tags.join(', ')}`);
    
    return tags;
}

/**
 * Formata descri√ß√£o com informa√ß√µes adicionais
 * @param {string} description - Descri√ß√£o original
 * @param {Object} videoData - Dados do v√≠deo
 * @returns {string} - Descri√ß√£o formatada
 */
function formatDescription(description, videoData) {
    let formattedDesc = description || '';
    
    // Adicionar rodap√© padr√£o se n√£o estiver muito longa
    if (formattedDesc.length < 4500) { // Limite YouTube: 5000
        const footer = `

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üôè Pregador Manasses
üì∫ Se inscreva no canal para mais conte√∫do!
üîî Ative as notifica√ß√µes

#PregadorManasses #Prega√ß√£o #Palavra`;
        
        formattedDesc += footer;
    }
    
    console.log(`üìù Descri√ß√£o: ${formattedDesc.length} caracteres`);
    return formattedDesc.substring(0, 5000); // Garantir limite
}

/**
 * Valida dados do v√≠deo antes do upload
 * @param {Object} videoData - Dados do v√≠deo
 * @param {Object} videoFile - Informa√ß√µes do arquivo
 */
function validateVideoData(videoData, videoFile) {
    console.log('üîç Validando dados do v√≠deo...');
       
    
    console.log('üìã DEBUG - videoData completo:', JSON.stringify(videoData, null, 2));
    console.log('üì∫ DEBUG - t√≠tulo recebido:', videoData.title);
    console.log('üìè DEBUG - comprimento do t√≠tulo:', videoData.title?.length);
    console.log('üìù DEBUG - tipo do t√≠tulo:', typeof videoData.title);
    
    // Validar t√≠tulo
    if (!videoData.title || videoData.title.length === 0) {
        throw new Error('‚ùå T√≠tulo √© obrigat√≥rio');
    }
    
    if (videoData.title.length > 100) {
        console.warn('‚ö†Ô∏è T√≠tulo muito longo, ser√° truncado');
        videoData.title = videoData.title.substring(0, 100);
    }
    
    // Validar arquivo
    if (!fs.existsSync(videoFile.filePath)) {
        throw new Error('‚ùå Arquivo de v√≠deo n√£o encontrado');
    }
    
    // Verificar tamanho (YouTube: m√°x 256GB, mas vamos limitar em 2GB)
    const maxSize = 2 * 1024 * 1024 * 1024; // 2GB
    if (videoFile.fileSize > maxSize) {
        throw new Error(`‚ùå Arquivo muito grande: ${videoFile.fileSizeFormatted}`);
    }
    
    // Verificar formato
    const supportedFormats = [
        'video/mp4',
        'video/avi',
        'video/mov',
        'video/wmv',
        'video/flv',
        'video/webm'
    ];
    
    if (!supportedFormats.includes(videoFile.mimeType)) {
        console.warn(`‚ö†Ô∏è Formato ${videoFile.mimeType} pode n√£o ser suportado`);
    }
    
    console.log('‚úÖ Valida√ß√£o conclu√≠da');
}

/**
 * Monitora progresso do upload
 * @param {number} totalSize - Tamanho total do arquivo
 * @returns {Function} - Fun√ß√£o de callback para progresso
 */
function createProgressCallback(totalSize) {
    let uploadedBytes = 0;
    const startTime = Date.now();
    
    return function(bytesUploaded) {
        uploadedBytes = bytesUploaded;
        const progress = ((uploadedBytes / totalSize) * 100).toFixed(1);
        const elapsed = (Date.now() - startTime) / 1000;
        const speed = uploadedBytes / elapsed / 1024 / 1024; // MB/s
        
        process.stdout.write(
            `\rüöÄ Upload: ${progress}% ` +
            `(${(uploadedBytes / 1024 / 1024).toFixed(1)}MB/${(totalSize / 1024 / 1024).toFixed(1)}MB) ` +
            `${speed.toFixed(1)} MB/s`
        );
    };
}

/**
 * Faz upload do v√≠deo para o YouTube
 * @param {Object} videoData - Dados do v√≠deo do Notion
 * @param {Object} videoFile - Informa√ß√µes do arquivo baixado
 * @returns {Object} - Resultado do upload
 */
async function uploadToYoutube(videoData, videoFile) {
    try {
        console.log('üöÄ Iniciando upload para YouTube...');
        
        // 1. Validar dados
        validateVideoData(videoData, videoFile);
        
        // 2. Preparar metadados
        const videoMetadata = {
            snippet: {
                title: videoData.title.substring(0, 100),
                description: formatDescription(videoData.description, videoData),
                tags: processTags(videoData.tags),
                categoryId: getCategoryId(videoData.category),
                defaultLanguage: 'pt',
                defaultAudioLanguage: 'pt'
            },
            status: {
                privacyStatus: formatPrivacyStatus(videoData.privacy),
                selfDeclaredMadeForKids: false,
                embeddable: true,
                publicStatsViewable: true
            }
        };
        
        console.log('üìã Metadados preparados:');
        console.log(`   üì∫ T√≠tulo: ${videoMetadata.snippet.title}`);
        console.log(`   üîí Privacidade: ${videoMetadata.status.privacyStatus}`);
        console.log(`   üìÇ Categoria: ${videoMetadata.snippet.categoryId}`);
        console.log(`   üè∑Ô∏è Tags: ${videoMetadata.snippet.tags.length}`);
        
        // 3. Configurar stream de upload
        const fileStream = fs.createReadStream(videoFile.filePath);
        const progressCallback = createProgressCallback(videoFile.fileSize);
        
        console.log(`üìÅ Arquivo: ${videoFile.fileName}`);
        console.log(`üìä Tamanho: ${videoFile.fileSizeFormatted}`);
        console.log('üöÄ Enviando...');
        
        const startTime = Date.now();
        
        // 4. Fazer upload
        const response = await youtube.videos.insert({
            part: ['snippet', 'status'],
            requestBody: videoMetadata,
            media: {
                body: fileStream
            }
        });
        
        const uploadTime = ((Date.now() - startTime) / 1000).toFixed(1);
        console.log(`\n‚úÖ Upload conclu√≠do em ${uploadTime}s!`);
        
        // 5. Processar resposta
        const videoId = response.data.id;
        const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
        const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
        
        console.log('üé¨ Informa√ß√µes do v√≠deo:');
        console.log(`   üÜî ID: ${videoId}`);
        console.log(`   üîó URL: ${videoUrl}`);
        console.log(`   üñºÔ∏è Thumbnail: ${thumbnailUrl}`);
        
        // 6. Verificar se v√≠deo foi processado
        try {
            await new Promise(resolve => setTimeout(resolve, 2000)); // Aguardar 2s
            
            const videoInfo = await youtube.videos.list({
                part: ['status', 'processingDetails'],
                id: videoId
            });
            
            const status = videoInfo.data.items[0]?.status;
            console.log(`üìä Status: ${status?.uploadStatus || 'unknown'}`);
            
        } catch (statusError) {
            console.warn('‚ö†Ô∏è N√£o foi poss√≠vel verificar status:', statusError.message);
        }
        
        return {
            success: true,
            videoId: videoId,
            videoUrl: videoUrl,
            thumbnailUrl: thumbnailUrl,
            uploadDate: new Date().toISOString(),
            uploadTimeSeconds: parseFloat(uploadTime),
            fileSize: videoFile.fileSize,
            title: videoMetadata.snippet.title,
            privacy: videoMetadata.status.privacyStatus
        };
        
    } catch (error) {
        console.error('\n‚ùå Erro no upload para YouTube:', error.message);
        
        // Analisar tipos de erro espec√≠ficos
        if (error.code === 403) {
            throw new Error('‚ùå Sem permiss√£o para upload (verificar quota/API)');
        } else if (error.code === 400) {
            throw new Error('‚ùå Dados inv√°lidos para upload');
        } else if (error.message.includes('quota')) {
            throw new Error('‚ùå Quota da API YouTube excedida');
        } else if (error.message.includes('file')) {
            throw new Error('‚ùå Problema com o arquivo de v√≠deo');
        }
        
        throw error;
    }
}

/**
 * Atualiza thumbnail do v√≠deo (opcional)
 * @param {string} videoId - ID do v√≠deo
 * @param {string} thumbnailPath - Caminho da thumbnail
 */
async function updateThumbnail(videoId, thumbnailPath) {
    try {
        if (!fs.existsSync(thumbnailPath)) {
            throw new Error('Arquivo de thumbnail n√£o encontrado');
        }
        
        console.log('üñºÔ∏è Atualizando thumbnail...');
        
        await youtube.thumbnails.set({
            videoId: videoId,
            media: {
                body: fs.createReadStream(thumbnailPath)
            }
        });
        
        console.log('‚úÖ Thumbnail atualizada');
        
    } catch (error) {
        console.warn('‚ö†Ô∏è Erro ao atualizar thumbnail:', error.message);
    }
}

/**
 * Obt√©m informa√ß√µes do canal
 */
async function getChannelInfo() {
    try {
        const response = await youtube.channels.list({
            part: ['snippet', 'statistics'],
            mine: true
        });
        
        if (response.data.items.length > 0) {
            const channel = response.data.items[0];
            return {
                id: channel.id,
                title: channel.snippet.title,
                subscriberCount: channel.statistics.subscriberCount,
                videoCount: channel.statistics.videoCount
            };
        }
        
        return null;
        
    } catch (error) {
        console.warn('‚ö†Ô∏è Erro ao obter info do canal:', error.message);
        return null;
    }
}

module.exports = {
    uploadToYoutube,
    updateThumbnail,
    getChannelInfo,
    getCategoryId,
    formatPrivacyStatus,
    processTags,
    formatDescription
};

/*
üéØ PRINCIPAIS FUNCIONALIDADES:
‚úÖ UPLOAD COMPLETO:
Metadados otimizados (t√≠tulo, descri√ß√£o, tags)
Barra de progresso em tempo real
Valida√ß√µes rigorosas antes do upload
M√∫ltiplos formatos de v√≠deo suportados
üõ°Ô∏è VALIDA√á√ïES E SEGURAN√áA:
‚úÖ Limites de tamanho e formato
‚úÖ T√≠tulos e descri√ß√µes otimizadas
‚úÖ Tags processadas corretamente
‚úÖ Tratamento de erros espec√≠ficos
üìä RECURSOS AVAN√áADOS:
‚úÖ Monitoramento de progresso
‚úÖ Informa√ß√µes do canal
‚úÖ Configura√ß√£o autom√°tica de privacidade
‚úÖ Suporte a thumbnails customizadas
üîß CONFIGURA√á√ïES AUTOM√ÅTICAS:
‚úÖ Categoria baseada no Notion
‚úÖ Idioma portugu√™s por padr√£o
‚úÖ Rodap√© personalizado na descri√ß√£o
‚úÖ Configura√ß√µes de embeddable 
*/