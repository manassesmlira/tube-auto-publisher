const fs = require('fs');
const path = require('path');
const { uploadToYoutube, updateThumbnail, getChannelInfo } = require('./utils/youtube-uploader');
const { markAsUploaded, markAsError } = require('./utils/update-notion');
const { cleanupTempFile } = require('./utils/drive-downloader');
const { downloadVideoById } = require('./2downloadvideo');
const { fetchVideoById } = require('./1fetchvideos');
require('dotenv').config();

/**
 * Valida configura√ß√µes do YouTube antes do upload
 */
function validateYouTubeConfig() {
    console.log('üîç Validando configura√ß√µes do YouTube...');
    
    const required = [
        'GOOGLE_CLIENT_ID',
        'GOOGLE_CLIENT_SECRET',
        'GOOGLE_REFRESH_TOKEN'
    ];
    
    const missing = required.filter(key => !process.env[key]);
    
    if (missing.length > 0) {
        throw new Error(`‚ùå Configura√ß√µes YouTube faltando: ${missing.join(', ')}`);
    }
    
    console.log('‚úÖ Configura√ß√µes YouTube validadas');
}

/**
 * Prepara metadados otimizados para o YouTube
 * @param {Object} videoData - Dados do v√≠deo do Notion
 * @returns {Object} - Metadados formatados
 */
function prepareYouTubeMetadata(videoData) {
    try {
        console.log('üìã Preparando metadados para YouTube...');
        
        // T√≠tulo otimizado (m√°ximo 100 caracteres)
        let title = videoData.title || 'V√≠deo sem t√≠tulo';
        if (title.length > 100) {
            title = title.substring(0, 97) + '...';
            console.log(`‚úÇÔ∏è T√≠tulo truncado: "${title}"`);
        }
        
        // Descri√ß√£o otimizada (m√°ximo 5000 caracteres)
        let description = videoData.description || '';
        
        // Adicionar rodap√© personalizado
        const footer = `
        
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üé¨ Publicado automaticamente via Auto Publisher
üìÖ Data: ${new Date().toLocaleDateString('pt-BR')}
ü§ñ Sistema: YouTube Auto Upload v2.0
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

#AutoPublisher #YouTube #Automa√ß√£o`;
        
        const maxDescLength = 5000 - footer.length;
        if (description.length > maxDescLength) {
            description = description.substring(0, maxDescLength - 3) + '...';
            console.log('‚úÇÔ∏è Descri√ß√£o truncada para caber o rodap√©');
        }
        
        description += footer;
        
        // Tags processadas
        let tags = [];
        if (videoData.tags) {
            tags = videoData.tags
                .split(',')
                .map(tag => tag.trim())
                .filter(tag => tag.length > 0 && tag.length <= 500)
                .slice(0, 500); // Limite do YouTube
        }
        
        // Adicionar tags autom√°ticas
        const autoTags = ['auto-publisher', 'upload-automatico'];
        tags = [...tags, ...autoTags].slice(0, 500);
        
        // Categoria e privacidade
        const category = videoData.category || 'Education';
        const privacy = videoData.privacy || 'Public';
        
        const metadata = {
            title,
            description,
            tags,
            category,
            privacy: privacy.toLowerCase(),
            language: 'pt-BR',
            defaultLanguage: 'pt',
            categoryId: getCategoryId(category),
            privacyStatus: formatPrivacyStatus(privacy)
        };
        
        console.log('üìã Metadados preparados:');
        console.log(`   üì∫ T√≠tulo: "${metadata.title}" (${metadata.title.length} chars)`);
        console.log(`   üìù Descri√ß√£o: ${metadata.description.length} chars`);
        console.log(`   üè∑Ô∏è Tags: ${metadata.tags.length} tag(s)`);
        console.log(`   üìÇ Categoria: ${metadata.category} (ID: ${metadata.categoryId})`);
        console.log(`   üîí Privacidade: ${metadata.privacy}`);
        
        return metadata;
        
    } catch (error) {
        console.error('‚ùå Erro ao preparar metadados:', error.message);
        throw error;
    }
}

/**
 * Mapeia categoria para ID do YouTube (duplicado aqui para standalone)
 */
function getCategoryId(category) {
    const categoryMap = {
        'Education': '27',
        'Entertainment': '24',
        'Music': '10',
        'Gaming': '20',
        'Sports': '17',
        'Science & Technology': '28',
        'News & Politics': '25',
        'Howto & Style': '26',
        'People & Blogs': '22',
        'Comedy': '34',
        'Film & Animation': '1',
        'Autos & Vehicles': '2'
    };
    
    return categoryMap[category] || '27';
}

/**
 * Formata status de privacidade (duplicado aqui para standalone)
 */
function formatPrivacyStatus(privacy) {
    const privacyMap = {
        'Public': 'public',
        'Unlisted': 'unlisted',
        'Private': 'private'
    };
    
    return privacyMap[privacy] || 'public';
}

/**
 * Verifica se arquivo √© v√°lido para upload
 * @param {string} filePath - Caminho do arquivo
 * @returns {Object} - Resultado da valida√ß√£o
 */
function validateVideoFile(filePath) {
    try {
        console.log('üîç Validando arquivo de v√≠deo...');
        
        if (!fs.existsSync(filePath)) {
            throw new Error('‚ùå Arquivo n√£o encontrado');
        }
        
        const stats = fs.statSync(filePath);
        const fileSize = stats.size;
        const fileName = path.basename(filePath);
        const extension = path.extname(fileName).toLowerCase();
        
        // Verificar extens√£o suportada
        const supportedFormats = ['.mp4', '.mov', '.avi', '.wmv', '.flv', '.webm', '.mkv'];
        if (!supportedFormats.includes(extension)) {
            throw new Error(`‚ùå Formato n√£o suportado: ${extension}`);
        }
        
        // Verificar tamanho (limite YouTube: 128GB)
        const maxSize = 128 * 1024 * 1024 * 1024; // 128GB
        if (fileSize > maxSize) {
            throw new Error(`‚ùå Arquivo muito grande: ${fileSize} bytes`);
        }
        
        const minSize = 1024 * 1024; // 1MB
        if (fileSize < minSize) {
            throw new Error(`‚ùå Arquivo muito pequeno: ${fileSize} bytes`);
        }
        
        console.log('‚úÖ Arquivo v√°lido para upload');
        console.log(`   üìÅ Nome: ${fileName}`);
        console.log(`   üìä Tamanho: ${(fileSize / 1024 / 1024).toFixed(2)} MB`);
        console.log(`   üé¨ Formato: ${extension}`);
        
        return {
            isValid: true,
            filePath,
            fileName,
            fileSize,
            extension
        };
        
    } catch (error) {
        console.error('‚ùå Erro na valida√ß√£o do arquivo:', error.message);
        return {
            isValid: false,
            error: error.message
        };
    }
}

/**
 * Executa upload completo para o YouTube
 * @param {Object} videoData - Dados do v√≠deo
 * @param {string} filePath - Caminho do arquivo
 * @returns {Object} - Resultado do upload
 */
async function uploadToYouTubeComplete(videoData, filePath) {
    const startTime = Date.now();
    try {
        console.log('üöÄ INICIANDO UPLOAD PARA YOUTUBE...');
        console.log('‚ïê'.repeat(50));
        console.log(`üé¨ T√≠tulo: ${videoData.title}`);
        console.log(`üìÅ Arquivo: ${path.basename(filePath)}`);
        
        // 1. Validar configura√ß√µes
        validateYouTubeConfig();
        
        // 2. Validar arquivo
        const fileValidation = validateVideoFile(filePath);
        if (!fileValidation.isValid) {
            throw new Error(`Arquivo inv√°lido: ${fileValidation.error}`);
        }
        
        // 3. Preparar metadados
        const metadata = prepareYouTubeMetadata(videoData);
        
        // 4. Obter informa√ß√µes do canal
        let channelInfo = null;
        try {
            channelInfo = await getChannelInfo();
            if (channelInfo) {
                console.log(`üì∫ Canal: ${channelInfo.title}`);
                console.log(`üë• Inscritos: ${channelInfo.subscriberCount}`);
                console.log(`üé¨ V√≠deos: ${channelInfo.videoCount}`);
            }
        } catch (channelError) {
            console.warn('‚ö†Ô∏è Erro ao obter info do canal:', channelError.message);
        }
        
        // 5. Preparar dados do arquivo
        const stats = fs.statSync(filePath);
        const fileSize = stats.size;
        const fileName = path.basename(filePath);
        const mimeType = 'video/mp4';

        console.log('üìä Dados do arquivo:');
        console.log(`üìÅ Nome: ${fileName}`);
        console.log(`üìä Tamanho: ${(fileSize / 1024 / 1024).toFixed(2)} MB`);
        console.log(`üìã Tipo: ${mimeType}`);
        
        // 6. Executar upload
        console.log('‚¨ÜÔ∏è Enviando para YouTube...');
        const uploadResult = await uploadToYoutube(videoData, { filePath, fileSize, fileName, mimeType });
        
        // 7. Calcular estat√≠sticas
        const uploadTime = ((Date.now() - startTime) / 1000).toFixed(1);
        const uploadSpeed = (fileValidation.fileSize / 1024 / 1024 / uploadTime).toFixed(1);
        
        console.log('‚ïê'.repeat(50));
        console.log('‚úÖ UPLOAD CONCLU√çDO COM SUCESSO!');
        console.log(`üé¨ Video ID: ${uploadResult.videoId}`);
        console.log(`üîó URL: ${uploadResult.videoUrl}`);
        console.log(`‚è±Ô∏è Tempo total: ${uploadTime}s`);
        console.log(`üöÄ Velocidade: ${uploadSpeed} MB/s`);
        console.log(`üîí Privacidade: ${uploadResult.privacy}`);
        
        // Retornar resultado completo
        return {
            success: true,
            videoId: uploadResult.videoId,
            videoUrl: uploadResult.videoUrl,
            privacy: uploadResult.privacy,
            thumbnailUrl: uploadResult.thumbnailUrl,
            uploadDate: new Date().toISOString(),
            uploadTimeSeconds: parseFloat(uploadTime),
            uploadSpeed: parseFloat(uploadSpeed),
            fileSize: fileValidation.fileSize,
            fileName: fileValidation.fileName,
            channelInfo,
            metadata
        };
        
    } catch (error) {
        const errorTime = ((Date.now() - startTime) / 1000).toFixed(1);
        console.error('‚ïê'.repeat(50));
        console.error('‚ùå ERRO NO UPLOAD:');
        console.error(`üí• Erro: ${error.message}`);
        console.error(`‚è±Ô∏è Falhou ap√≥s: ${errorTime}s`);
        console.error('‚ïê'.repeat(50));
        
        return {
            success: false,
            error: error.message,
            uploadDate: new Date().toISOString(),
            uploadTimeSeconds: parseFloat(errorTime),
            attempts: 1
        };
    }
}


/**
 * Processo completo: buscar dados + upload + atualizar Notion
 * @param {string} pageId - ID da p√°gina no Notion
 * @param {string} filePath - Caminho do arquivo (opcional, far√° download se n√£o fornecido)
 * @returns {Object} - Resultado completo
 */
async function uploadVideoById(pageId, filePath = null) {
    let downloadResult = null;
    let fileToCleanup = null;
    
    try {
        console.log('üöÄ PROCESSO COMPLETO DE UPLOAD...');
        console.log(`üìÑ ID da p√°gina: ${pageId}`);
        
        // 1. Buscar dados do v√≠deo
        console.log('üìã Buscando dados do v√≠deo...');
        const videoData = await fetchVideoById(pageId);
        
        if (!videoData) {
            throw new Error('‚ùå V√≠deo n√£o encontrado no Notion');
        }
        
        console.log(`‚úÖ V√≠deo encontrado: "${videoData.title}"`);
        
        // 2. Download se necess√°rio
        if (!filePath) {
            console.log('üì• Arquivo n√£o fornecido, fazendo download...');
            downloadResult = await downloadVideoById(pageId);
            
            if (!downloadResult.success) {
                throw new Error(`Falha no download: ${downloadResult.error}`);
            }
            
            filePath = downloadResult.downloadResult.filePath;
            fileToCleanup = filePath;
            console.log(`‚úÖ Download conclu√≠do: ${downloadResult.downloadResult.fileName}`);
        } else {
            console.log(`üìÅ Usando arquivo fornecido: ${filePath}`);
        }
        
        // 3. Upload para YouTube
        const uploadResult = await uploadToYouTubeComplete(videoData, filePath);
        
        // 4. Atualizar Notion
        console.log('üìù Atualizando Notion...');
        try {
            await markAsUploaded(pageId, uploadResult, videoData);
            console.log('‚úÖ Notion atualizado com sucesso');
        } catch (notionError) {
            console.warn('‚ö†Ô∏è Erro ao atualizar Notion:', notionError.message);
            // N√£o falha o processo se o upload YouTube foi bem-sucedido
        }
        
        // 5. Limpeza (manter arquivo se upload foi bem-sucedido)
        if (fileToCleanup && !uploadResult.success) {
            try {
                cleanupTempFile(fileToCleanup);
                console.log('üßπ Arquivo tempor√°rio removido');
            } catch (cleanupError) {
                console.warn('‚ö†Ô∏è Erro na limpeza:', cleanupError.message);
            }
        }
        
        // Resultado final
        const finalResult = {
            success: uploadResult.success,
            pageId,
            videoData,
            uploadResult,
            downloadResult
        };
        
        if (uploadResult.success) {
            console.log('üéâ PROCESSO FINALIZADO COM SUCESSO!');
            console.log(`üé¨ V√≠deo publicado: ${uploadResult.videoUrl}`);
        } else {
            console.error('üí• PROCESSO FALHOU!');
            console.error(`‚ùå Erro: ${uploadResult.error}`);
        }
        
        return finalResult;
        
    } catch (error) {
        console.error('üí• ERRO NO PROCESSO COMPLETO:', error.message);
        
        // Marcar como erro no Notion
        try {
            await markAsError(pageId, error.message);
            console.log('üìù Erro registrado no Notion');
        } catch (notionError) {
            console.warn('‚ö†Ô∏è Erro ao registrar no Notion:', notionError.message);
        }
        
        // Limpeza em caso de erro
        if (fileToCleanup) {
            try {
                cleanupTempFile(fileToCleanup);
                console.log('üßπ Arquivo tempor√°rio removido');
            } catch (cleanupError) {
                console.warn('‚ö†Ô∏è Erro na limpeza:', cleanupError.message);
            }
        }
        
        return {
            success: false,
            error: error.message,
            pageId,
            videoData: videoData || null,
            downloadResult,
            uploadResult: null
        };
    }
}

/**
 * Fun√ß√£o principal - executar upload se chamado diretamente
 */
async function main() {
    try {
        // Verificar argumentos
        const pageId = process.argv[2];
        const filePath = process.argv[3]; // Opcional
        
        if (!pageId) {
            throw new Error('‚ùå Uso: node 3_upload_youtube.js <page_id> [file_path]');
        }
        
        console.log('üöÄ INICIANDO SCRIPT DE UPLOAD...');
        console.log('‚ïê'.repeat(50));
        
        // Executar processo completo
        const result = await uploadVideoById(pageId, filePath);
        
        if (result.success) {
            console.log('üéâ UPLOAD FINALIZADO COM SUCESSO!');
            console.log(`üé¨ V√≠deo: ${result.uploadResult.videoUrl}`);
            process.exit(0);
        } else {
            console.error('üí• UPLOAD FALHOU!');
            console.error(`‚ùå Erro: ${result.error}`);
            process.exit(1);
        }
        
    } catch (error) {
        console.error('üí• ERRO FATAL:');
        console.error(error.message);
        process.exit(1);
    }
}

// Executar se chamado diretamente
if (require.main === module) {
    main();
}

module.exports = {
    uploadToYouTubeComplete,
    uploadVideoById,
    prepareYouTubeMetadata,
    validateVideoFile,
    validateYouTubeConfig
};

/*
üéØ PRINCIPAIS FUNCIONALIDADES:
üé¨ UPLOAD COMPLETO:
Busca dados do Notion
Download autom√°tico se necess√°rio
Upload otimizado para YouTube
Atualiza status no Notion
üìã METADADOS INTELIGENTES:
‚úÖ T√≠tulos otimizados (100 chars)
‚úÖ Descri√ß√µes com rodap√© autom√°tico
‚úÖ Tags processadas e validadas
‚úÖ Categoria e privacidade corretas
üõ°Ô∏è VALIDA√á√ïES ROBUSTAS:
‚úÖ Configura√ß√µes YouTube v√°lidas
‚úÖ Arquivo compat√≠vel e tamanho OK
‚úÖ Metadados dentro dos limites
‚úÖ Canal acess√≠vel
üìä MONITORAMENTO AVAN√áADO:
‚úÖ Tempo e velocidade de upload
‚úÖ Informa√ß√µes do canal
‚úÖ Logs detalhados de progresso
‚úÖ Estat√≠sticas completas
üßπ GEST√ÉO DE ARQUIVOS:
‚úÖ Limpeza autom√°tica em caso de erro
‚úÖ Mant√©m arquivo se upload OK
‚úÖ Tratamento de arquivos tempor√°rios
‚úÖ Verifica√ß√£o de espa√ßo
üîÑ PROCESSO INTEGRADO:
‚úÖ Combina download + upload
‚úÖ Atualiza√ß√£o autom√°tica Notion
‚úÖ Tratamento de erros robusto
‚úÖ C√≥digos de sa√≠da apropriados
*/